
```dataview 	
TABLE without id	
file.outlinks AS "OUTGOING", 	
file.inlinks AS "BACKLINKS"	
WHERE file.name = this.file.name 
```

#reference #лекция #java
# Links


# Description
### Что будет изучаться:
1) ООП
2) Система сборки Maven
3) Функциональное программирование (Лямбды, StreamAPI)
4) Многопоточное программирование
5) Работа с сетью и базами данных (HttpClient, Retrofit, JDBC)
6) ORM (hibernate)
7) Современные возможности Java (21 ver)
8) **Модуль Spring Framework**
	1) spring MVC (реализация REST API)
	2) Spring DATA JPA (ORM взаимодействия с БД и сущностями)
	3) Миграции баз данных (Flyway)
	4) Разворачивание приложения: docker + docker compose
	5) Узнаем про PostgreSQL и Redis

*Реализация проекта Magic: **автобатлер** с карточками Magic the Gathering* **ОБЯЗАТЕЛЬНО**

**Особенности:**
1) ОО язык
2) легко переносим на другие платформы
3) строго типизирован
4) язык интерпретируемый и компилируемый
5) автоматически управляет памятью
6) ~100% обратная совместимость со старыми версиями
7) есть возможность использовать интерфейс для вызова нативных методов (C/C++)



---
## Объектно-ориентированный подход к написанию программ
Затронем принципы SOLID
**Класс** - это описание какого-то объекта, который надо создать в оперативной памяти./ программное описание некоторой предметной модели, которое содержит свойства (поля) и поведение (методы).
Предметная модель - некий набор предметов, из которой мы моделируем программное описание.
**Экземпляр класса** - переменная, которая хранит ссылку на объект класса.
**Объект** - экземпляр (воплощение в памяти программы) класса, пригодный для взаимодействия с другими объектами.
Конструктор класса тоже метод.

Конструктор необходим для создания в памяти объектов класса
Выделяют два типа конструктора: по умолчанию (который находится неявно в классе и исчезает при создании пользовательского, вызывается только если нет пользовательского) и пользовательский
Пользовательский конструктор позволяет при создании объекта инициализировать поля класса.

Создание объекта называется его инициализацией
new создает в памяти объект и с помощью конструктора инициализирует в нем поля, после чего в переменную возвращается ссылка на область памяти, где хранится объект.
Если объект не инициализирован, то в нем хранится пустая ссылка - null.

Парадигмы ООП
1) Наследование (extends). Класс дочерний расширяет класс базовый и содержит все его публичные поля.
2) Инкапсуляция - данные и функции находятся во взаимосвязи. Сокрытие доступа к полям и методам. Все что содержит класс изнутри, это скрыто.
3) Полиморфизм - когда объект одного и того же базового класса может быть проинициализирован от базового класса и от его наследника. Базовый класс может принимать разные формы своих наследников. ???

Мета-классы - позволяет обойти модификаторы доступа и получить доступ к приватным полям. С помощью свойства мета-класса. Но очень сажает производительность. Использовать в крайней необходимости.

В SOLID используются больше интерфейсы, чем классы.

Модификаторы доступа.
(табличка)

Процедурно-ориентированное программирование.
Алгоритмы + структуры данных = программа
Сначала подготавливаются алгоритмы для манипуляции данными, затем выбирается структура для их организации.

ООП.
Данные + алгоритмы = программа.
Сначала подготавливаются структуры данных для обработки, а затем способы манипуляции ими.

(Объектный подход) Модель данных "Звездная система"
Берем абстрактный класс и расширяем его наследниками, которые более точно описывыют абстрактный класс. 
![[Pasted image 20250916094057.png]]
Далее необходимо описать взаимодействие между объектами. Например, вычисление орбиты звездных тел вокруг звезды с учетом их свойств (способы манипуляции данными).

![[Pasted image 20250916094407.png]]

Object - самый главный класс, от которого неявно наследуются классы.

> [!Разница между "равно" и equals.]
> ...

Хэшкод - ?????

Статические методы. 
Статические поля и методы существуют в единственном экземпляре и создаются во время запуска приложения.
Чтобы получить доступ к статическим методам и полям, не нужно объявлять экземпляр класса, доступ получается через точку.

(СИЛЬНЫЕ ССЫЛКИ И СЛАБЫЕ ССЫЛКИ)

Интерфейс - определяет некоторое поведение, оставляя реализацию конкретному классу.

Обобщенные типы (generics)
Из C++ template\<typename T\> 
Позволяют обобщать работу с любыми типами данных
Помимо классов можно создавать и обобщенные методы использующие универсальные параметры.
![[Pasted image 20250916100726.png]]

SOLID
![[Pasted image 20250916100659.png]]
https://habr.com/ru/companies/ruvds/articles/426413/
1) S: Нарушается, когда один класс выполняет много лишнего, чего не должно быть, т.е. "божественный класс". Означает, что каждый класс должен  иметь единственное назначение и все ресурсы для его осуществления инкапсулированы (находятся) в пределах этого класса. 
2) O: Класс может быть закрыт для расширения функционала, но закрыт для модификации. Для добавления новых функций в базовый класс нужно сделать его наследника, расширяющего (extends) базовый.
	Правильная реализация на примере бармена и официанта, каждый из них реализует свой функционал:
	![[Pasted image 20250916101620.png]]
3) L: Если некий подкласс можно заменить базовым классом (абстрактным или интерфейсом) без потери функциональности для клиента, то лучше так и сделать. 
4) I: Если в одном интерфейсе определено много функциональности, разной по ответственности, то имеет смысл разделить его на несколько.
5) D: Классы верхнего уровня иерархии не должны зависеть от классов нижнего уровня. Зависимость классов всех уровней должна быть от абстракций. Абстракции не должны зависеть от деталей реализаций. Детали реализации должны зависеть от абстракций.
	![[Pasted image 20250916102624.png]]


---
## Многопоточное программирование
### Процессы и потоки
Процесс - запущенная программа в ОС
Внутри процесса - потоки. Главный поток создается в точке входа и работает до конца работы программы. Дочерний поток создается в процессе выполнения программы от главного потока. От дочернего может быть дочерний.
Процесс состоит из потоков выполнения.
### Разделяемая память (shared)
Все потоки взаимодействуют с объектами в общей для процесса памяти.
К каждому объекту могут иметь доступ одновременно все потоки.
**Доступ к разделяемому ресурсу (объекту)**
Блокирующий (mutex, mutual exclusion) - взаимная блокировка ресурс доступен только одному потоку в текущий момент.
Не блокирующий: Lock-free - потоки не блокируют выполнение друг друга (не deadlock)
Wait-free - потокам гарантируется выполнение операций в их кванте времени без необходимости ожидания.
Все wait-free программы являются и lock-free.
**Локальный кэш**
На всех ядрах есть маленькие регистры ячейки памяти. L1 - самый малый по размеру кэш, но самый быстрый. Все изменения во время выполнения потока (переменные, значения) хранятся сначала в локальной памяти, после выполнения потока все изменения фиксируются затем в оперативной памяти. Локальная память находится близко к CPU.

Race condition - когда выполняются два потока и они одновременно меняют одну и ту же переменную(ячейку памяти), после выполнения неизвестно какой поток займет эту ячейку.

Каждый поток имеет свою локальную память (кэш) на том ядре, где исполняется.
Кэш делится на уровни: L1, L2, L3 относительно близости к вычислительным блокам.
Потоки не видят изменений локальных кэшей друг друга.

**Атомарность (atomicity)**
Нельзя повлиять на то, что происходит внутри программы. 
Атомарная операция - когда невозможно наблюдать частичный результат его выполнения. Состояние системы видимо либо до операции, либо после.
В java:
1) Запись в поля переменных (int, boolean, byte, short, char, float, object) всегда атомарна
2) В поля long/double атомарна запись старших и младших 32-бит.

Как достичь атомарности операций?
1) Зачем, чтобы при выполнении операций с одним объектом между потоками гарантировать предсказуемость изменений.
2) Примитивы синхронизации: оператор synchronized позволяет "схватить" мьютекс объекта для единоличного использования одним потоком.
3) Модификатор volatile на поле класса гарантирует, что запись и чтение переменной будет производится всегда из общей памяти, а не из локального кэша.

**Состояния потока**

**Как создавать потоки**
1) Класс Thread и запуск потока
	Объект с кодом выполнения оборачивается в объект потока (thread). Далее запускается поток на JVM и отправляется в планировщик задач ОС и затем в CPU. Любой объект в Thread должен реализовать метод Runnable.

**Анонимный метод - нет названия, используется как лямбда выражения. Нельзя переиспользовать.**

**Проблема синхронизации**
1) Мьютекс - взаимное исключение
2) Семафор - счетчик, который ограничивает количество потоков, имеющий доступ к одному разделяемому ресурсу.
3) Монитор 

**Примитивы синхронизации**
