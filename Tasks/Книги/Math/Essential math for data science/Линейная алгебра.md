
```dataview 	
TABLE without id	
file.outlinks AS "OUTGOING", 	
file.inlinks AS "BACKLINKS"	
WHERE file.name = this.file.name 
```

#reference

# Links

# Description
Линейная алгебра изучает линейные системы, но представляет их в виде векторных пространств и матриц. Она лежит в основе многих прикладных областей математики статистики, исследования операций, науки о данных и машинного обучения. Она применяется во многих библиотеках питона, которые используются в статистике. Но лучше знать явно как они работают.
## Что такое вектор?
Из курса школьной математики, вектор это направленный отрезок в пространстве. Часто его применяют именно в декартовой системе координат (Cartesian plane).
**Цель вектора - наглядно представить данные. Например, у вас есть данные о площади дома в 18000 кв.м. и его стоимости в 260000 долларов. Мы можем представить в виде вектора \[18000,260000\]**. 
*Чтобы обозначить вектор в Python, используется список из двух элементов.*

***Для решения задач в сфере машинного обучения, лучше всего использовать библиотеку NumPy, так как с ней удобнее вычислять математические формулы. Она более эффективна, чем обычный питон. Но также будет использоваться библиотека SymPy, но не так часто как нампай.***

В книге "Python для сложных задач" рассматривает библиотеку NumPy более подробно.

Векторы имеют разнообразное применение во многих сферах. В информатике векторы используются, чтобы импортировать данные и их использовать. Почти все в компьютерах представлено векторами.

В этой главе просто рассказывается про общие понятия о векторах. 
### Сложение и объединение векторов
Сами по себе векторы неинтересны. Но интересно их складывать и комбинировать, ведь по сути вы объединяете движения двух векторов в один вектор.
**Чтобы сложить вектора в библиотеке NumPy, нужно просто сложить два списка. Они сложатся так же как векторы.**
Действие сложения векторов коммутативно, то есть место каждого слагаемого не имеет значения.
### Масштабирование векторов
Вектор можно увеличить или уменьшить, умножив его на скалярное значение.

> [!NOTE] Управление данными - управление векторами
> Любую операцию с данными можно представить как операции с векторами. Допустим возьмем вычисление среднего значения стоимости домов и средней площади дома. Просто сложим вектора стоимости и площади всех домов и разделим на количество. Получим вектор, содержащий эти средние значения.

Если вектора умножаются на отрицательный скаляр, то они меняют направление на противоположное. Но если подумать еще, то вектор все равно остается на той же прямой, что и был до этого. Это все подводит нас к ключевому моменту, а именно к линейной зависимости.

### Размах и линейная зависимость
Эти две операции как масштабирование и сложение векторов позволяют реализовать простую, но эффективную идею. С помощью этих операций мы можем получить любой желаемый вектор.
Все это пространство возможных векторов называется **линейной оболочкой**. **Если у нас есть два вектора, направленные в разные стороны, они линейной независимы и образуют неограниченную линейную оболочку**.

Но в каком случае мы ограничены в создании векторов?
Когда два вектора лежат на одной прямой, то любые комбинации с этими векторами также будут лежать на этой прямой. Это делает эти векторы **линейно зависимыми**.

В трехмерном пространстве, когда у нас есть набор линейно зависимых векторов, мы часто застреваем на плоскости в пространстве меньшей размерности. 
Позже будет изучен определитель, чтобы проверять линейную зависимость. Многие задачи становятся неразрешимыми, если вектора линейно зависимы (системы уравнений). 
## Линейные преобразования
Концепция сложения двух векторов с фиксированным направлением, но с разным масштабом для получения различных комбинированных векторов важна. Этот комбинированный вектор, за исключением линейной зависимости, может быть направлен в любую сторону и быть любой длины. Это и есть линейные преобразования, когда мы используем один вектор, чтобы преобразовать с его помощью другой подобно функции.
### Базисные векторы
В качестве базисных векторов для линейных преобразований используются i и j. 
Они представляют собой базис: ![[Pasted image 20250915201107.png]]
Базис представлен в виде матрицы. В матрицах удобно хранить данные. 
Мы можем получить любой вектор, используя i и j, складывая и масштабируя их. Длина каждого из них равна 1.
Например, мы хотим вектор \[3,2\]. Чтобы его получить, нужно изменить базисные векторы.
![[Pasted image 20250915201434.png]]
Это и есть **линейное преобразование**. Мы исказили пространство путем масштабирования и сложения базисных векторов и получили нужный результирующий вектор.
С помощью линейных преобразований можно добиться четырех действий: масштабирование, поворот, сдвиг, инверсия.
![[Pasted image 20250915201900.png]]
Эти четыре линейных преобразования являются основными в линейной алгебре.
**Важно отметить, что все преобразования не могут быть нелинейными, иначе они приведут к искривленным преобразованиям.**
### Матрично-векторное умножение
Концепция того, куда попадают базисные векторы после преобразования важна, потому что позволяет нам не только создавать векторы, но и преобразовывать уже существующие.

Формула для преобразования вектора U с помощью базисных векторов (базиса):![[Pasted image 20250915202648.png]]
Такое преобразование вектора называется **Умножение вектора на матрицу.** Эта формула позволяет быстро масштабировать и складывать базисные векторы и применять это преобразование к любому вектору.
Чтобы выполнить преобразование в питоне, используется библиотека NumPy и оператор **dot()**. 
![[Pasted image 20250915203223.png]] 
Оно выполняет скалярное произведение матрицы и вектора.

> [! ]
> Предпочтительнее выделять базисные векторы, а затем их объединять в матрицу. Эту матрицу следует транспонировать. Это связано с тем, что функция array() в NumPy соединяет векторы в строки, а не в столбцы.
> Также, i и j базисные векторы называют **i-hat и j-hat**.


> [!NOTE] СТОИТ ОТМЕТИТЬ
> Некоторые линейные преобразования могут преобразовывать линейное пространство в пространство с большим или меньшим измерением. Именно это и делают неквадратные матрицы.


## Умножение матриц
Умножение матриц представляет собой набор линейных преобразований, которые имеют вид матрешки. Сначала применяется преобразование внутреннее, затем оно суммируется со следующим линейным преобразованием.
![[Pasted image 20250916110937.png]]
Например, мы можем объединить сдвиг и поворот в одно преобразование, а затем применить его к вектору:
![[Pasted image 20250916111145.png]]
**Чтобы выполнить данное действие в Python, используем библиотеку NumPy и функцию matmul() или @**. Затем используем это преобразование и применим его к вектору.

**Для объединения матриц лучше использовать matmul() и @, вместо dot(). **

Линейные преобразования лежат в основе математической статистики. От импорта данных до числовых операций с линейной регрессией, логистической регрессией и нейронные связи

## Определитель
Когда выполняются линейные преобразования, мы изменяем пространство путем сжатия и расширения. Степень изменения пространства и есть определитель. 
Определитель показывает как линейное преобразование изменяет площадь. Показывает насколько изменяется масштаб выбранной области в векторном пространстве при линейных преобразованиях.

Простые сдвиги или повороты, которые не влияют на площадь поверхности, не должны влиять на определитель.

При масштабировании определитель будет увеличиваться или уменьшаться, так как будет увеличиваться или уменьшаться площадь выборки. При изменении ориентации (i и j меняются местами) определитель будет отрицательным.

Самая важная информация, которую дает определитель - это информация о том, является ли преобразование линейно зависимым. Если определитель равен нулю, то все пространство сжалось до меньшей размерности.
## Специальные типы матриц
1) Квадратные матрицы. Одинаковое количество строк и столбцов.
2) Единичная матрица (Identity matrix). Квадратная матрица, у которой по диагонали единицы, а остальные значения равны нулю.
3) Обратная матрица. Вычисляется с помощью библиотеки numpy или sympy. При умножении обычной матрицы и ее обратной матрицы, получаем единичную матрицу.
4) Диагональная матрица. По диагонали ненулевые значения, остальные нули.
5) Треугольная матрица. Выше и по диагонали ненулевые значения, остальные нули.
6) Разреженная матрица. В основном состоят из нулей и содержат очень мало ненулевых элементов.
## Системы уравнения и обратные матрицы
Одним из способов применения линейной алгебры - решение систем уравнений.
Попробуем решить систему уравнений с помощью компьютера. Порядок решения: найти обратную матрицу системы и с помощью выражения ![[Pasted image 20250920225209.png]] решить систему уравнений.

Используем библиотеку sympy, так как numpy не позволяет увидеть единичную матрицу в таком виде, как в первой библиотеке из-за десятичных дробей с плавающей точкой.
Используем метод inv() над матрицей, чтобы найти ее обратную матрицу.
В sympy чтобы перемножить матрицы, используется \*, а не @.

Однако, на практике недостаточная точность вычислений с плавающей точкой не окажет существенного влияния на наши ответы, поэтому для вычисления x (решений) можно использовать Numpy.


> [!NOTE] Системы уравнений в линейном программировании
> Этот метод решения систем уравнений также используется в линейном программировании, где неравенства определяют ограничения, а целевая функция минимизируется или максимизируется. В приложении А подробно рассматривается данный метод. 

## Собственные векторы и собственные значения
Матричная декомпозиция - это разбиение матрицы на базовые компоненты, подобно разложению чисел на множители (например, 10 можно разбить на умножение 2 и 5).
Используется для нахождения обратной матрицы и определителей, а также в **линейной регрессии**.

Существует множество способов декомпозиции матрицы. **В главе 5 будет использоваться метод матричной декомпозиции, QR разложение для выполнения линейной регрессии**.

В этой главе будет затронут популярный метод: собственное разложение, который часто используется в машинном обучении и анализе данных. **Этот метод работает только с квадратными матрицами**.

В методе декомпозиции собственных значений есть два компонента: собственные значения (лямбда) и собственный вектор (v).
Матрица разбивается на умножение двух матриц:
![[Pasted image 20251005170850.png]]
Справедливо следующее тождество: ![[Pasted image 20251005171036.png]]
*Если А - исходная матрица, то она состоит из собственного вектора v и собственного значения лямбда. Для каждого измерения родительской матрицы существует свой собственный вектор и собственное значение, но не все матрицы можно разложить на собственный вектор и собственное значение. Иногда в итоге получаются комплексные (мнимые) числа.*

(Как вычислять собственные векторы и собственные значения в NumPy показано в Colab).

**Чтобы восстановить матрицу А по собственным векторам и собственным значениям**, нужно эту формулу ![[Pasted image 20251005171036.png]] некоторые изменения. И тогда получится это:
![[Pasted image 20251005173638.png]]
Q - собственные векторы, Л - собственные значения в диагональной форме, Q(-1) - обратная матрица Q. 
(Диагональная форма означает, что вектор дополняется матрицей из нулей и занимает диагональную строку, как в единичной матрице)
