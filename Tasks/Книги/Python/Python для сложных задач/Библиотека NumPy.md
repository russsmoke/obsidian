
```dataview 	
TABLE without id	
file.outlinks AS "OUTGOING", 	
file.inlinks AS "BACKLINKS"	
WHERE file.name = this.file.name 
```

#reference

# Links
#библиотека #программирование #python 
# Description
Эта библиотека позволяет эффективно загружать, хранить данные, находящиеся в оперативной памяти, и управлять ими. Данные можно представить в [[Все типы данных можно представить в виде массивов чисел.|различном виде]]. Вне зависимости от типа данных первым шагом к их анализу является преобразование в числовые массивы.
Эффективное хранение и работа с числовыми массивами очень важны для процесса исследования данных. Библиотека NumPy (Numerical Python), обеспечивает эффективный интерфейс для хранения и обработки плотных буферов данных. Массивы библиотеки походи на тип данных list в языке питон, но обеспечивают гораздо более эффективное хранение и обработку данных с ростом размеров массивов.
**Чтобы импортировать библиотеку в оболочку IPython, нужно прописать так:** ```import numpy as np```. 

Массивы библиотеки нампай могут быть только одного типа, если типы отличаются, то выполняется повышающее приведение типов (например, от целочисленного к числам с плавающей точкой). Можно явно задавать типы (dtype =). Можно явно задавать многомерные массивы с помощью генератора (range(i,i+3) for i in \[2,3,4\] или по другому). Есть готовые методы, чтобы удобнее было создавать массивы: 
1) Заполнение нулями: .zeros(количество, тип) 
2) Двумерный массив единиц: .ones((строки, столбцы), тип)
3) Двумерный массив, заполненный значениями: .full((строки, столбцы), значение) 
4) Массив с линейной последовательностью: .arange(первое значение, последнее значение, шаг) 
5) Массив с равными интервалами: .linspace(начало, конец, количество частей, на которое делиться интервал) 
6) Массив со случайными значениями от 0 до 1: .random.random((строки, столбцы)) 
7) Массив со случайными значениями со средним 0 и стандартным отклонением 1: .random.normal(0,1,(строки, столбцы)) 
8) Массив со случайными целыми значениями в интервале от 1 до 10: .random.randint(0,10,(строки, столбцы)) 
9) Массив единичной матрицы: .eye(размерность)
10) Неинициализированный массив с произвольными значениями из памяти: .empty(количество значений)

### Введение в массивы

Будут рассмотрены следующие темы: 
1) Получение атрибутов массивов: размер, форма, объем занимаемой памяти и типов данных массивов 
2) Индексация массивов: получение и изменение отдельных элементов массива 
3) Получение срезов массива: получение и изменение значение подмассивов внутри большого массива 
4) Изменение формы массива 
5) Объединение и разбиение массива

#### Атрибуты массива
У каждого массива есть атрибуты ndim (число размерностей), shape (размер каждой размерности) и size (общий размер массива)
#### Индексация массива: доступ к отдельным элементам
Такая же индексация для массивов нампай, как и в обычном списке. Также можно использовать отрицательный индексы для перечисления с конца. 
Обращаться к многомерным массивам можно с помощью кортежей (строка, столбец). 
Так как тип данных фиксирован, то при попытке вставить число с плавающей точкой в массив целочисленных значений оно округлиться до целого.
#### Срезы массивов: доступ к подмассивам
Массив\[начало : конец : шаг] для одномерных массивов 
Массив\[ начало: конец : шаг, начало : конец : шаг, ...] перечисление через запятую 
Одна из востребованных операций являются получение одной строки или столбца. Массив\[ : , номер столбца] для столбца, массив\[номер строки, : ] для строки.
#### Подмассивы как представления
В отличии от срезов списка в классическом питоне, в нампай срез возвращает представление (view), а не копию массива. Изменение в срезе отражается и в исходном массиве. Это позволяет легко менять фрагменты массивов не копируя их в буфер.
#### Создание копий массивов
Иногда просто хочется сделать копию массива, без представления. Делается это с помощью метода copy. Приписывается он к массиву, который хотим скопировать и результат присваиваем в новую переменную.
#### Изменение формы массива
Метод reshape(размер массива). Размер исходного массива должен соответствовать размеру результирующего и в большинстве случаев будет возвращать представления исходного массива. 
Операция изменения формы часто используется для представления одномерного массива в двумерную матрицу строку или вектор столбец. Настолько часто, что был реализован новый синтаксис np.newaxis с применением срезов (x\[np.newaxis, :] - вектор строка, x\[ : , np.newaxis] - вектор столбец)
#### Слияние и разбиение массивов
Библиотека позволяет сливать несколько массивов в один и разбивать их на маленькие массивы. 
1) Слияние или объединение массивов выполняется с помощью методов np.concatenate, np.vstack, np.hstack. Первый метод принимает в качестве первого аргумента список массивов (в квадратных скобках). Можно объединять и двумерные массивы (различаются только оси объединения: axis=0 это добавление строк, axis=1 это добавление столбцов в качестве второго аргумента). Для слияния массивов с различными измерениями следует использовать вертикальное или горизонтальное слияние (np.vstack np.hstack np.dstack (третье измерение)). 
2) Разбиение массивов выполняется с помощью методов np.split, np.vsplit, np.hsplit. Каждому методу нужно передать в качестве первого аргумента разбиваемый массив, а в качестве второго - список индексов, задающих точки разбиения. Функции возвращают список массивов, нужно присвоить массивам через запятую.
#### Вычисления с массивами. Универсальные функции
NumPy используется из за гибкого и простого интерфейса для оптимизированных вычислений с массивами данных. Ключ к быстрому выполнению операций над массивами - использование векторизованных операций, реализуемых посредством универсальных функций (ufuncs). 
1) Медлительность циклов. Реализация языка питон по умолчанию (CPython) выполняет операции очень медленно аз-за своей гибкости. Обнаруживается медлительность при многократном повторении мелких операций. 
2) Введение в универсальные функции. Векторизованный подход спроектирован так, чтобы перенести цикл в скомпилированный слой, лежащий в основе библиотеки, что обеспечивает гораздо более высокую производительность. 
3) Обзор универсальных функций в библиотеке. Есть два вида универсальных функций: унарные, принимающие один аргумент, и бинарные, с двумя аргументами. 
4) Арифметические операции над массивами. Универсальные функции просты в использовании, поскольку применяют обычные арифметические операторы. С помощью этих операторов можно вычислять массивы. Есть эквивалентные универсальные функции операторам. 
5) Абсолютное значение. Помимо арифметических операторов, в библиотеке есть универсальная функция вычисления абсолютного значения (np.abs() не путать с abs()). Эта универсальная функция может обрабатывать комплексные значения, возвращая их модуль. 
6) Тригонометрические функции. В библиотеке также могут использоваться тригонометрические функции( np.cos, np.sin, np.tan, np.arcsin, np.arccos, np.arctan).
7) Показательные функции и логарифмы. Np.exp(x) возведение экспоненту в степень, np.exp2(x) возведение 2 в степень, np.log(x) натуральный, np.log2(x), np.log10(x), np.expm1(x) exp(x) - 1, np.log1p(x) log(1+x). 
8) Специализированные универсальные функции. В библиотеке существует немало других функций: гиперболические тригонометрические функции, функции поразрядной арифметики, сравнения, преобразования из радианов в градусы, округления и получения остатков от деления. В документации много других функций. Подмодуль scipy.special (from scipy import special) содержит специализированные и сложные функции. 
	Следующие функции помогут в статистических вычислениях: 
		a. Гамма-функции (обобщенные факториалы) и тому подобные функции special.gamma(x), special.gammaln(x), special.beta(x) 
		b. Функция ошибок (интеграл от гауссовской функции), дополнительная и обратная к ней функции special.erf(x), special.erfc(x), special.erfinv(x).
9) Продвинутые возможности универсальных функций. 
	1) Сохранение результатов в массиве. Удобно создать массив с результатами вычисления. Вместо временного массива можно воспользоваться этой возможностью для записи результатов вычислений непосредственно в нужное место в памяти. Сделать это можно с помощью дополнительного аргумента out в любой функции вычисления (например, np.multiply(x, 10, out=y). Эту возможность можно использовать с представлениями массивов (out = y\[\:\:2\]) 
	2) Сводные показатели. Бинарные универсальные функции предлагают возможность вычислять некоторые сводные данные непосредственно на основе объекта. Например, операция reduce(x) многократно применяет операцию к элементам массива, пока не останется один результат (np.add.reduce(x), np.multiply.reduce(x)). Или функция, которая сохраняет в массив промежуточные результаты (np.multiply.accumulate(x)). Но в данных конкретных случаях существую специализированные функции в библиотекке (np.sum, np.prod, np.cumsum, np.cumprod). 
	3) Векторные произведения. Все универсальные функции могут выводить результаты применения соответствующей операции ко всем парам двух аргументов с помощью метода outer (np.multiply.outer(x, x)).
Универсальные функции дают возможность работать с массивами данных различных форм и размеров, используя набор операций под названием транслирование.

### Агрегирование. Минимум, максимум и все что посередине
При работе с большим объемом данных, в первую очередь нужно вычислить сводные статистические показатели по этим данным (Среднее значение и стандартное отклонение наиболее распространенные).

Чтобы задать рандомный массив нужно использовать библиотеку: 
``` 
import numpy as np
rng = np.random.default_rng()
mass = rng.random(100) #100 это длина массива одномерного

M = rng.integers(0, 10, (3,4)) #от 0 до 10 размер массива 3х4 заполнены рандомно
```

В библиотеке NumPy имеются быстрые функции агрегирования для работы с массивами.
1) **Суммирование значений в массиве.** В чистом языке программирования это можно сделать с помощью функции sum(). А в библиотеке существует такая же функция с таким же названием, только выполняется она быстрее, так как выполняется в компилированном коде (np.sum() - вызов функции). 
	Они не идентичны, функция суммирования может иметь различный набор аргументов и может работать с многомерными массивами.
2) **Минимум и максимум**. Также в чистом языке программирования есть функции минимального и максимального значения. Но NumPy-версии функций работают намного быстрее. Поэтому следует использовать их. 
	Библиотека поддерживает и другие агрегирующие операции, реализованные как методы самого объекта массива (np.min() то же самое что и mass.min()).
3) **Многомерные сводные показатели**. Агрегирование по столбцу или строке одни из частых видов операции агрегирования. По умолчанию все функции агрегирования возвращают сводный показатель по всему массиву. Но они принимают дополнительный аргумент, позволяющий указать ось, по которой вычисляется сводный показатель (axis = 0 вертикальная ось, axis = 1 горизонтальная ось. Аргументы показывают какая ось будет свернута).
4) **Другие функции агрегирования**. Библиотека предоставляет много других агрегирующих функций. Большинство имеет NaN-безопасный эквивалент, вычисляющий результат с игнорированием отсутствующих значений. *отмеченных специальным значением с плавающей точкой NaN*, определенным организацией IEEE.
	1) Список полезных агрегирующих функций, доступных в библиотеке:
		1) **np.sum и np.nansum** Вычисляет сумму элементов.
		2) **np.prod и np.nanprod** Вычисляет произведение элементов.
		3) **np.mean и np.nanmean** Вычисляет среднее значение элементов.
		4) **np.std и np.nanstd** Вычисляет стандартное отклонение.
		5) **np.var и np.nanvar** Вычисляет дисперсию.
		6) **np.min и np.nanmin** Вычисляет минимальное значение.
		7) **np.max и np.nanmax** Вычисляет максимальное значение
		8) **np.argmin и np.nanargmin** Возвращает индекс минимального значения.
		9) **np.argmax и np.nanargmax** Возвращает индекс максимального значения.
		10) **np.median и np.nanmedian** Вычисляет медиану элементов.
		11) **np.percentile и np.nanpercentile** Вычисляет квантили элементов.
		12) **np.any** Проверяет, существуют ли элементы со значением True
		13) **np.all** Проверяет, все ли элементы со значением True
5) **Пример: чему равен средний рост президентов США**. С помощью библиотека pandas можно вытащить из данных csv файла нужный столбец с данными. Затем с ними вычислять сводные показатели. Чтобы графически показать полученные данные можно использовать библиотеку Matplotlib. В книге ярко показано как можно использовать функции библиотек.
### Операции над массивами. Транслирование.
В главе 6 рассматривались универсальные функции для векторизации операций и замены медленных стандартных циклов. В этой главе затронем транслирование (broadcasting) - набор правил, которые позволяют применять функции из библиотеки NumPy для выполнения бинарных операций (сложение, вычитание, умножение и др.) с массивами разных форм и размеров.
1) **Введение в транслирование**. Для массивов одинакового размера бинарные операции выполняются поэлементно:
	```
	import numpy as np
	a = np.array([0,1,2])
	b = np.array([5,5,5])
	print(a+b)
	```
	Транслирование дает возможность выполнять подобные виды бинарных операций с массивами различных размеров, например, можно прибавить скалярное значение (как нульмерный массив) к массиву, и он произведен сложение поэлементно. Значение как бы растягивается в массив той же размерности и складывается с каждым элементом.
	Аналогично можно рассматривать транслирование на массивы большего размера. Например, у нас есть двумерный массив 3х3, заполненный единицами. К нему прибавляется одномерный массив, этот массив растягивается во второе измерение и складывается с каждый одномерным массивом в матрице.
	```
	M = np.ones((3,3))
	a = np.array([0,1,2])
	print(M + a)
	#[[1,2,3], [1,2,3], [1,2,3]]
	```
	Еще один пример, где растягиваются два массива, чтобы соответствовать размерам друг друга: один горизонтальный вектор и один вертикальный. В результате мы получаем двумерный массив.
	В книге показано наглядно как выполняется транслирование.
2) **Правила транслирования**.
	- **Первое**: если размерности двух массивов отличаются, то форма (измерение) массива с меньшой размерностью дополняется единицами с ведущей (левой) стороны.
	- **Второе**: если формы двух массивов не совпадают в каком-то измерении, то массив с формой, равной 1 в данном измерении, растягивается вплоть до соответствия форме другого массива.
	- **Третье**: если в каком-либо измерении размеры массивов различаются и ни один не равен 1, то генерируется ошибка
3) **Примеры**.
	- Первый пример. Сложение двумерного массива и одномерного.
		```
		M.shape = (2,3)
		a.shape = (3,)
		#согласно первому правилу, добавляем недостающее измерение слева.
		M.shape => (2,3)
		a.shape => (1,3)
		#согласно правилу 2, первые измерения массивов различаются, растягиваем первое измерение массива a до первого измерения массива M
		M.shape => (2,3)
		a.shape => (2,3)
		#выполняем транслирование
		```
		- Второй пример. Сложение вертикального и горизонтального массивов
			```
			a.shape = (3,1)
			b.shape = (3,)
			#по правилу 1 дополняем недостающее измерение
			a.shape => (3,1)
			b.shape => (1,3)
			#по правилу 2 растягиваем измерения каждого массива
			a.shape => (3,3)
			b.shape => (3,3)
			#измерения должны совпадать
			```
		- Третий пример. Два несовместимых вектора
		```
		M.shape = (3,2)
		a.shape = (3,)
		#по правилу 1 добавляем слева недостающее измерение
		M.shape => (3,2)
		a.shape => (1,3)
		#по правилу 2 растягиваем измерения, чтобы они совпадали
		M.shape => (3,2)
		a.shape => (3,3)
		# итоговые формы не совпадают, поэтому вылезает ошибка
		```
		Можно было сделать их совместимыми, если бы по первому правилу мы добавляли единицу измерения не слева, а справа, но правила транслирования так не работают. Если захочется дополнить форму массива справа, то нужно поменять форму массива явно (np.newaxis).
		Данные правила транслирования применимы ко всем бинарным универсальным функциям.
4) **Транслирование на практике**.
	1) **[[Центрирование данных. Зачем оно нужно|Центрирование массива]]**: пусть есть массив из десяти наблюдений, каждое состоит из 3 значений. Сохраним эти данные в массиве размером 10х3.
		```
		rng = np.random.default_rng(seed=1701)
		X = rng.random((10,3))
		```
		Далее вычисляем среднее значение по первому измерению, используя функцию агрегирования mean:
		```
		Xmean = X.mean(axis=0)
		#array([0.38, 0.36, 0.63])
		```
		Теперь центрируем массив путем вычитания из исходных данных среднего значения (операция транслирования):
		```
		X_centered = X-Xmean
		```
		После можем проверить и окажется, что среднее центрированного массива близко к нулю.
	2) **Построение графика двумерной функции**. Одна из частых сфер применения транслирования - это визуализация двумерных функций (z = f(x,y)).
		```
		#задаем для x и y 50 шагов от 0 до 5
		x = np.linspace(0,5,50)
		y = np.linspace(0,5,50)[: , np.newaxis]
		z = np.sin(x)**10 + np.cos(10 + x*y)*np.cos(x)
		#Используем библиотеку Matplotlib для построения двумерного графика
		%matplotlib inline
		import matplotlib.pyplot as plt
			plt.imshow(z, origin = 'lower', extent = [0,5,0,5])
			plt.colorbar();
		```
### Сравнения, маски и булева логика
В этой главе будет показано использование булевых масок для проверки и изменения значений в массивах. Маскирование удобно для извлечения, модификации, подсчета или других операций с массивами. Например, найти числа, которые превышают какой то порог.
1) **Пример: подсчет количества дождливых дней.** Есть некоторая последовательность значений количества осадков в течении года в мм для некоторого города. Этот массив содержит 365 значений.
	Используем Pandas для извлечения данных.
	```
	import numpy as np
	from vega_datasets import data
	#Используем Pandas
	rainfall_mm = np.array(data.seattle_weather().set_index('date')['precipitation']['2015'])
	```
	В качестве первой простой визуализации рассмотрим гистограмму дождливых дней с помощью matplotlib.
	```
	%matplotlib inline
	import matplotlib.pyplot as plt
	plt.style.use('seaborn-whitegrid')
	plt.hist(rainfall_mm,40)
	```
	Гистограмма показывает лишь общее представление наших данных. Если мы вдруг захотим узнать сколько именно было дождливых дней или сколько дней были осадки 10 мм. Для этого самым простым вариантом получения ответа является перебор. Но библиотека NumPy позволяет с помощью маскирования получить быстрые ответы на такие вопросы. 
2) **Операторы сравнения как универсальные функции**. 
	Помимо арифметических операторов можно использовать операторы сравнения для массивов данных. Так, сравнение с числом массива вернет булева массив, который показывает поэлементное сравнение числа и значения в массиве. Результатом операторов сравнения **всегда является массив с данными булева типа**. Можно также выполнять поэлементное сравнение двух массивов и использовать составные выражения (2\*x == 2\*\*x). Есть шесть операторов сравнения (>, <, >=, <=, !=, \=\=). 
	Операторы сравнения могут также работать с массивами любых размеров и форм.
3) **Работы с булевыми массивами**.
	1) **Подсчет количества элементов**. 
		Для подсчета количества True в массиве удобно использовать функцию ```np.count_nonzero(условие)```. По другому можно использовать функцию ```np.sum(условие)```, где в качестве False выступает 0, а True 1. Преимущество второй функции в том, что подобно другим функциям агрегирования она может выполняться отдельно для любой оси (столбцы или строки).
		Чтобы быстро проверить наличие хотя бы одного True, можно воспользоваться функцией ```np.all(все ли значения удовлетворяют условию) или np.any(хотя бы одно удовлетворяет условию)```. Эти функции также можно использовать по определенной оси.
		**ИСПОЛЬЗУЮТСЯ ИСКЛЮЧИТЕЛЬНО ФУНКЦИИ БИБЛИОТЕКИ NUMPY**.
	2) **Булевы операторы**.
		Когда нужно отобрать значения по сложному условию, в ход пускают побитовые логические операторы (&, |, ^, ~). Как и обычные арифметические операторы, библиотека перегружает их с использованием универсальных функций, поэлементно работающих с (обычно булевыми) массивами.
		Например, нужно узнать количество дней, где осадки были между 10мм и 20мм.
		```np.sum((rainfall_mm > 10) & (rainfall_mm < 20))```.
		Не забываем использовать скобки.
		*В книге в таблице 9.2 представлены побитовые булевы операторы и эквивалентные им универсальные функции.*
	3) **Булевы массивы как маски**.
		Мы можем использовать булевы массивы, полученные из условия основного массива, как маски для извлечения значений, которые удовлетворяют условию.
		Чтобы выбрать нужные значения, достаточно проиндексировать исходный массив по этому булеву массиву. Такое действие носит название операции *наложения маски или маскирование*:
		```
		x[x<5] #array([4,0,3,3,1,3,4,0])
		#здесь мы проиндексировали массив по булеву массиву (x<5)
		```
		Маски можно комбинировать с другими универсальными функциями для вычисления статистических показателей по какому-либо критерию.
		В книге показаны примеры вычисления сводных показателей с помощью функций и булевых масок.
	4) **Ключевые слова and/or и операторы &/|**
		Ключевые слова и операторы казалось бы обозначают одно и то же, но это не так. 
		***Ключевые слова and и or работают с объектом как с единым целым, а операторы & и | оперируют отдельными битами внутри объектов.***
		В Питоне все ненулевые числа будут рассматриваться как истина.
		При применении к целым числам операторы манипулируют их битовыми представлениями, фактически применяя операции and и or к отдельным битам, составляющим числа.
		Для получения результата сравниваются соответствующие биты чисел.
		**При вычислении результата логических выражений с массивами правильно использовать именно булевы операторы, так как применение ключевых слов подразумевает сравнение объекта в целом, а массив формально не определяется как единый объект**.
		